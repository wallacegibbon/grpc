-module(route_guide_server_2).

%% The initial version of this file was generated by grpc.
%% This implementation demonstrates a few additional aspects:
%% - handling of metadata
%% - compression
%% - errors

-export([decoder/0,
         'GetFeature'/3, 'ListFeatures'/3, 'RecordRoute'/3, 'RouteChat'/3]).

-type 'RouteSummary'() ::
    #{point_count => integer(), feature_count => integer(),
      distance => integer(), elapsed_time => integer()}.

-type 'Point'() ::
    #{latitude => integer(), longitude => integer()}.

-type 'Rectangle'() ::
    #{lo => 'Point'(), hi => 'Point'()}.

-type 'RouteNote'() ::
    #{location => 'Point'(), message => string()}.

-type 'Feature'() ::
    #{name => string(), location => 'Point'()}.

-spec decoder() -> module().
%% The module (generated by gpb) used to encode and decode protobuf
%% messages.
decoder() -> route_guide.

%% RPCs for service 'RouteGuide'

-spec 'GetFeature'(Message::'Point'(), Stream::grpc:stream(), State::any()) ->
    {'Feature'(), grpc:stream()} | grpc:error_response().
%% This implementation shows a few features:
%% - how to access metadata that was sent by the client,
%% - how to compress a response message
%% - how to send an error response.
'GetFeature'(Message, Stream, _State) ->
    Feature = #{name => find_point(Message, data()),
                location => Message}, 
    case grpc:metadata(Stream) of
        #{<<"password">> := <<"secret">>} ->
            {Feature, Stream};
        #{<<"compressed">> := <<"true">>} ->
            %% receive a compressed message
            {Feature, Stream};
        #{<<"metadata-bin">> := <<1,2,3,4>>} ->
            {Feature, Stream};
        #{<<"metadata-bin-response">> := <<"true">>} ->
            %% add a binary metadata element
            Stream2 = grpc:set_headers(Stream, 
                                         #{<<"response-bin">> => <<1,2,3,4>>}), 
            {Feature, Stream2};
        #{<<"header_overwrite">> := <<"true">>} = Headers ->
            Path = <<"/routeguide.RouteGuide/GetFeature">>,
            try 
                %% Method 1: match on stream
                #{authority := <<"changed">>,
                  scheme := <<"changed">>,
                  method := <<"POST">>,
                  path := Path} = Stream,
                %% Method 2: via functions
                <<"changed">> = grpc:authority(Stream),
                <<"changed">> = grpc:scheme(Stream),
                <<"POST">> = grpc:method(Stream),
                Path = grpc:path(Stream),
                {error, 3, <<"invalid argument">>, Stream}
            catch
                _:_Error ->
                    {error, 13, <<"test failed">>, Stream}
            end;
        #{<<"compression">> := <<"true">>} ->
            %% send a compressed message
            {Feature, grpc:set_compression(Stream, gzip)};
        _ -> 
            {error, 7, <<"permission denied">>, Stream}
    end.

-spec 'ListFeatures'(Message::'Rectangle'(), Stream::grpc:stream(), State::any()) ->
    {['Feature'()], grpc:stream()} | grpc:error_response().
%% This adds metadata to the header and to the trailer that are sent to the client.
'ListFeatures'(_Message, Stream, _State) ->
    Stream2 = grpc:send(grpc:set_headers(Stream, 
                                             #{<<"info">> => <<"this is a test-implementation">>}), 
                          #{name => "Louvre",
                            location => #{latitude => 4,
                                          longitude => 5}}),
    Stream3 = grpc:set_trailers(Stream2, #{<<"nr_of_points_sent">> => <<"2">>}),
    {[#{name => "Tour Eiffel",
        location => #{latitude => 3,
                      longitude => 5}}], Stream3}.

-spec 'RecordRoute'(Message::'Point'() | eof, Stream::grpc:stream(), State::any()) ->
    {continue, e_gprc:stream(), any()} | {'RouteSummary'(), grpc:stream()}.
%% This is a client-to-server streaming RPC. After the client has sent the last message
%% this function will be called a final time with 'eof' as the first argument. This last
%% invocation must return the response message.
'RecordRoute'(FirstPoint, Stream, undefined) ->
    %% The fact that State == undefined tells us that this is the 
    %% first point. Set the starting state, and return 'continue' to 
    %% indicate that we are not done yet.
    {continue, Stream, #{t_start => erlang:system_time(1),
                         acc => [FirstPoint]}};
'RecordRoute'(eof, Stream, #{t_start := T0, acc := Points}) ->
    %% receiving 'eof' tells us that we need to return a result.
    {#{elapsed_time => erlang:system_time(1) - T0,
       point_count => length(Points),
       feature_count => count_features(Points),
       distance => distance(Points)}, Stream};
'RecordRoute'(Point, Stream, #{acc := Acc} = State) ->
    {continue, Stream, State#{acc => [Point | Acc]}}.

-spec 'RouteChat'(Message::'RouteNote'() | eof, Stream::grpc:stream(), State::any()) ->
    {['RouteNote'()], e_gprc:stream(), any()} | {['RouteNote'()], grpc:stream()}.
%% This is a bidirectional streaming RPC. If the client terminates the stream
%% this function will be called a final time with 'eof' as the first argument.
'RouteChat'(In, Stream, undefined) ->
    'RouteChat'(In, Stream, []);
'RouteChat'(eof, Stream, _) ->
    {[], Stream};
'RouteChat'(#{location := Location} = P, Stream, Data) ->
    Messages = proplists:get_all_values(Location, Data),
    {Messages, Stream, [{Location, P} | Data]}.


%% Supporting functions

data() ->
    DataFile = filename:join([code:lib_dir(grpc, examples), 
                              "route_guide", "server", "route_guide_data.dat"]),
    {ok, [Points]} = file:consult(DataFile),
    Points.

find_point(_Location, []) ->
    "";
find_point(Location, [#{location := Location, name := Name} | _]) ->
    Name;
find_point(Location, [_ | T]) ->
    find_point(Location, T).

count_features(_) -> 42.
distance(_) -> 42.
